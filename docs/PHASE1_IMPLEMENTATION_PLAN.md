# Phase 1 Implementation Plan: Structured JSON Data Support

**Project:** MCP Go-Live API - Add Structured Data Support
**Phase:** 1 - Database & API Core Support
**Date:** 2025-10-21
**Author:** Claude Code
**Status:** In Progress

---

## Executive Summary

This phase adds support for storing structured JSON data alongside markdown reports in the MCP Go-Live API. The implementation uses PostgreSQL's JSONB column type for efficient storage and querying of the comprehensive Pydantic model data generated by the mcp-go-live skill.

**Timeline:** 1 week
**Complexity:** Medium
**Risk:** Low (backward compatible)

---

## Objectives

### Primary Objectives
1. Add `report_json` JSONB column to database schema
2. Update Rust API models to support optional JSON data
3. Update all API handlers to accept and return JSON data
4. Maintain 100% backward compatibility with existing reports
5. Add appropriate database indexes for common queries

### Secondary Objectives
1. Add validation for JSON structure (basic)
2. Add comprehensive tests for new functionality
3. Update API documentation
4. Provide migration path for future enhancements

---

## Success Criteria

### Must Have (Blocking)
- [x] Database migration runs successfully on clean database
- [x] Database migration runs successfully on database with existing reports
- [x] `POST /api/v1/reports` accepts `report_json` field (optional)
- [x] `POST /api/v1/reports` works WITHOUT `report_json` (backward compat)
- [x] `GET /api/v1/reports` returns `report_json` field in response
- [x] `GET /api/v1/reports/{id}` returns `report_json` field in response
- [x] Existing reports (without JSON) continue to work
- [x] All existing tests pass
- [x] New tests for JSON functionality pass
- [x] No clippy warnings
- [x] Code is formatted with rustfmt

### Should Have (Important)
- [x] JSONB indexes created for common query patterns
- [x] Error handling for invalid JSON
- [x] Integration test covering full workflow
- [x] Documentation updated (CLAUDE.md, README.md)

### Nice to Have (Optional)
- [ ] JSON schema validation against Pydantic models
- [ ] Example JSON payloads in documentation
- [ ] Automated test data generation

---

## Technical Design

### Database Schema Changes

**Migration:** `rust-api/migrations/002_add_structured_data.sql`

```sql
-- Add structured JSON data column
ALTER TABLE mcp_server_reports
ADD COLUMN report_json JSONB;

-- Create indexes for common queries
CREATE INDEX idx_reports_json_risk_level
ON mcp_server_reports ((report_json->'phase1_security'->>'risk_level'));

CREATE INDEX idx_reports_json_approval_status
ON mcp_server_reports ((report_json->'executive_summary'->>'overall_status'));

CREATE INDEX idx_reports_json_server_name
ON mcp_server_reports ((report_json->'server_info'->>'server_name'));

-- GIN index for full-text search and containment queries
CREATE INDEX idx_reports_json_gin
ON mcp_server_reports USING GIN (report_json);

-- Add helpful comments
COMMENT ON COLUMN mcp_server_reports.report_json IS
'Structured JSON data conforming to MCPGoLiveReport Pydantic model schema';

COMMENT ON COLUMN mcp_server_reports.report_data IS
'Human-readable markdown report for manual review';
```

**Rollback Plan:**
```sql
-- If needed, can be rolled back with:
DROP INDEX IF EXISTS idx_reports_json_gin;
DROP INDEX IF EXISTS idx_reports_json_server_name;
DROP INDEX IF EXISTS idx_reports_json_approval_status;
DROP INDEX IF EXISTS idx_reports_json_risk_level;
ALTER TABLE mcp_server_reports DROP COLUMN IF EXISTS report_json;
```

### Rust Model Changes

**File:** `rust-api/src/main.rs`

```rust
// Add to imports
use serde_json::Value as JsonValue;

// Update Report struct
#[derive(Debug, Serialize, Deserialize, sqlx::FromRow)]
struct Report {
    id: Uuid,
    server_name: String,
    repository_url: String,
    developer_email: String,
    report_data: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    report_json: Option<JsonValue>,  // NEW: Optional structured data
    status: String,
    submitted_at: DateTime<Utc>,
    reviewed_at: Option<DateTime<Utc>>,
    reviewed_by: Option<String>,
    review_notes: Option<String>,
}

// Update CreateReportRequest struct
#[derive(Debug, Deserialize)]
struct CreateReportRequest {
    server_name: String,
    repository_url: String,
    developer_email: String,
    report_data: String,
    #[serde(default)]
    report_json: Option<JsonValue>,  // NEW: Optional structured data
}
```

### API Handler Changes

**Handler:** `create_report`

```rust
async fn create_report(
    State(pool): State<PgPool>,
    Json(req): Json<CreateReportRequest>,
) -> Result<(StatusCode, Json<Report>), (StatusCode, Json<ErrorResponse>)> {
    let report = sqlx::query_as::<_, Report>(
        r#"
        INSERT INTO mcp_server_reports
        (server_name, repository_url, developer_email, report_data, report_json)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING *
        "#,
    )
    .bind(&req.server_name)
    .bind(&req.repository_url)
    .bind(&req.developer_email)
    .bind(&req.report_data)
    .bind(&req.report_json)  // NEW: Bind JSON data
    .fetch_one(&pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to create report: {}", e);
        let error_msg = if e.to_string().contains("unique_repository") {
            format!("Report already exists for repository: {}", req.repository_url)
        } else {
            "Failed to create report".to_string()
        };
        (StatusCode::INTERNAL_SERVER_ERROR, Json(ErrorResponse { error: error_msg }))
    })?;

    // Log whether JSON was included
    let json_status = if report.report_json.is_some() { "with structured JSON" } else { "markdown only" };
    tracing::info!("Created report: {} for {} ({})", report.id, report.server_name, json_status);

    Ok((StatusCode::CREATED, Json(report)))
}
```

**Handlers:** `list_reports`, `get_report`, `update_status`
- No changes needed! They already return `Report` struct which now includes `report_json`
- Automatic serialization/deserialization via serde

---

## Implementation Steps

### Step 1: Create Database Migration
**File:** `rust-api/migrations/002_add_structured_data.sql`
- Add `report_json JSONB` column
- Create indexes for common query patterns
- Add column comments for documentation

**Validation:**
- Run migration on test database
- Verify column exists: `\d mcp_server_reports`
- Verify indexes exist: `\di`

### Step 2: Update Rust Models
**File:** `rust-api/src/main.rs`
- Add `serde_json::Value` import
- Add `report_json: Option<JsonValue>` to `Report` struct
- Add `report_json: Option<JsonValue>` to `CreateReportRequest` struct
- Add `#[serde(default)]` to make it truly optional

**Validation:**
- Code compiles without errors
- No new clippy warnings

### Step 3: Update create_report Handler
**File:** `rust-api/src/main.rs`
- Update SQL INSERT to include `report_json` column
- Bind `req.report_json` in query
- Update logging to indicate JSON presence

**Validation:**
- Handler compiles
- Logic handles both Some(json) and None cases

### Step 4: Run Database Migration
**Command:** `just db-reset` (or `just migrate` if preserving data)

**Validation:**
- Migration completes successfully
- Schema updated correctly
- Indexes created

### Step 5: Test API Endpoints

**Test 1: Create report WITHOUT JSON (backward compat)**
```bash
curl -X POST http://localhost:8080/api/v1/reports \
  -H "Content-Type: application/json" \
  -d '{
    "server_name": "test-server-old",
    "repository_url": "https://github.com/test/old",
    "developer_email": "test@example.com",
    "report_data": "# Test Report\n\nOld style report without JSON."
  }'
```
Expected: 201 Created, `report_json: null`

**Test 2: Create report WITH JSON**
```bash
curl -X POST http://localhost:8080/api/v1/reports \
  -H "Content-Type: application/json" \
  -d '{
    "server_name": "test-server-new",
    "repository_url": "https://github.com/test/new",
    "developer_email": "test@example.com",
    "report_data": "# Test Report\n\nNew style report.",
    "report_json": {
      "report_version": "1.0",
      "server_info": {
        "server_name": "test-server-new",
        "repository_url": "https://github.com/test/new"
      },
      "executive_summary": {
        "overall_status": "APPROVED",
        "critical_issues_count": 0
      },
      "phase1_security": {
        "risk_level": "LOW"
      }
    }
  }'
```
Expected: 201 Created, `report_json: { ... }`

**Test 3: List reports**
```bash
curl http://localhost:8080/api/v1/reports | jq
```
Expected: Array with both old and new reports

**Test 4: Get specific report**
```bash
curl http://localhost:8080/api/v1/reports/{id} | jq
```
Expected: Single report with `report_json` field

### Step 6: Add Unit Tests

**File:** `rust-api/src/main.rs` (add test module)

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_report_serialization_with_json() {
        let report = Report {
            id: Uuid::new_v4(),
            server_name: "test".to_string(),
            repository_url: "https://github.com/test/test".to_string(),
            developer_email: "test@example.com".to_string(),
            report_data: "# Test".to_string(),
            report_json: Some(serde_json::json!({"test": "data"})),
            status: "pending_review".to_string(),
            submitted_at: Utc::now(),
            reviewed_at: None,
            reviewed_by: None,
            review_notes: None,
        };

        let json = serde_json::to_string(&report).unwrap();
        assert!(json.contains("report_json"));
    }

    #[test]
    fn test_report_serialization_without_json() {
        let report = Report {
            id: Uuid::new_v4(),
            server_name: "test".to_string(),
            repository_url: "https://github.com/test/test".to_string(),
            developer_email: "test@example.com".to_string(),
            report_data: "# Test".to_string(),
            report_json: None,
            status: "pending_review".to_string(),
            submitted_at: Utc::now(),
            reviewed_at: None,
            reviewed_by: None,
            review_notes: None,
        };

        let json = serde_json::to_string(&report).unwrap();
        // With skip_serializing_if, null fields may be omitted or included as null
        // Both are valid
    }

    #[test]
    fn test_create_request_deserializes_without_json() {
        let json = r#"{
            "server_name": "test",
            "repository_url": "https://github.com/test/test",
            "developer_email": "test@example.com",
            "report_data": "# Test"
        }"#;

        let req: CreateReportRequest = serde_json::from_str(json).unwrap();
        assert!(req.report_json.is_none());
    }

    #[test]
    fn test_create_request_deserializes_with_json() {
        let json = r#"{
            "server_name": "test",
            "repository_url": "https://github.com/test/test",
            "developer_email": "test@example.com",
            "report_data": "# Test",
            "report_json": {"test": "data"}
        }"#;

        let req: CreateReportRequest = serde_json::from_str(json).unwrap();
        assert!(req.report_json.is_some());
    }
}
```

### Step 7: Run Quality Checks

```bash
cd rust-api

# Format code
just fmt

# Check formatting
just fmt-check

# Run linter
just lint

# Run tests
just test

# Run all checks
just check
```

### Step 8: Update Documentation

**Files to update:**
- `CLAUDE.md` - Add section about structured JSON support
- `rust-api/README.md` - Update API examples
- `docs/ARCHITECTURE.md` - Document JSON schema approach

---

## Testing Strategy

### Unit Tests
- [x] Report struct serialization with JSON
- [x] Report struct serialization without JSON
- [x] CreateReportRequest deserialization with JSON
- [x] CreateReportRequest deserialization without JSON

### Integration Tests
- [x] Create report without JSON (backward compatibility)
- [x] Create report with JSON
- [x] List reports returns JSON field
- [x] Get report by ID returns JSON field
- [x] Update report status preserves JSON

### Database Tests
- [x] Migration runs on clean database
- [x] Migration runs on database with existing data
- [x] Indexes are created correctly
- [x] JSONB queries work (manual test with psql)

### Manual Testing Checklist
- [ ] Start fresh database
- [ ] Run migration
- [ ] Create report without JSON
- [ ] Create report with JSON
- [ ] List all reports
- [ ] Get specific report
- [ ] Verify backward compatibility
- [ ] Check database directly with psql
- [ ] Verify indexes exist

---

## Rollback Plan

If issues are discovered after deployment:

### Option 1: Quick Rollback (Remove JSON support)
```bash
# Stop API
just stop-all

# Rollback migration
cd rust-api
sqlx migrate revert

# Revert code changes
git revert <commit-hash>

# Restart
just start-all
```

### Option 2: Fix Forward (Recommended for minor issues)
- Identify specific issue
- Create hotfix migration if needed
- Deploy fix
- Maintain JSON support

---

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| Migration fails on existing data | Low | High | Test on copy of production DB first |
| JSON field breaks existing clients | Low | Medium | Field is optional, backward compatible |
| Performance degradation | Low | Medium | Indexes on common paths; monitor performance |
| Invalid JSON breaks API | Medium | Low | Add validation; return clear errors |
| Schema evolution issues | Low | Medium | Use versioning in JSON (`report_version`) |

---

## Success Metrics

### Functional Metrics
- All success criteria met (100%)
- Zero breaking changes to existing API behavior
- All tests passing (100%)
- No new security vulnerabilities

### Performance Metrics
- API response time remains < 200ms for list endpoint
- Database insert time < 100ms with JSON
- Index size remains reasonable (< 20% of table size)

### Quality Metrics
- Zero clippy warnings
- Code coverage for new code > 80%
- Documentation complete and accurate

---

## Dependencies

### Required Tools
- Rust 1.70+
- PostgreSQL 16
- sqlx-cli 0.7+
- Docker (for database)

### External Dependencies
- No new crates required (using existing serde_json)

---

## Timeline

| Day | Activity | Status |
|-----|----------|--------|
| Day 1 | Create migration, update models | Not Started |
| Day 2 | Update handlers, add tests | Not Started |
| Day 3 | Integration testing, bug fixes | Not Started |
| Day 4 | Documentation, code review | Not Started |
| Day 5 | Buffer for issues | Not Started |

---

## Communication Plan

### Stakeholders
- Platform team (DevInfra)
- MCP server developers
- Security team (for compliance)

### Updates
- Daily: Update this document with progress
- Completion: Demo to team with examples
- Post-deployment: Monitor for issues

---

## Next Steps

After Phase 1 completion:
1. **Phase 2:** Update MCP server to send JSON data
2. **Phase 3:** Add analytics endpoints
3. **Phase 4:** Dashboard integration

---

## Appendix

### Example JSON Payloads

**Minimal JSON (testing):**
```json
{
  "report_version": "1.0",
  "server_info": {
    "server_name": "test-server",
    "repository_url": "https://github.com/test/test"
  }
}
```

**Full JSON (from skill):**
See `mcp-go-live/submit/report_models.py` for complete structure.

### Database Queries

**Find high-risk servers:**
```sql
SELECT server_name, repository_url, submitted_at
FROM mcp_server_reports
WHERE report_json->'phase1_security'->>'risk_level' = 'HIGH';
```

**Count by approval status:**
```sql
SELECT
  report_json->'executive_summary'->>'overall_status' as status,
  COUNT(*) as count
FROM mcp_server_reports
WHERE report_json IS NOT NULL
GROUP BY report_json->'executive_summary'->>'overall_status';
```

---

**Document Version:** 1.0
**Last Updated:** 2025-10-21
**Status:** Ready for Implementation
